
# Лекция 1-1: Введение в многопоточность

## Основные темы лекции:

### 1. Что такое многопоточность?
В лекции дается введение в концепцию многопоточного программирования. Объясняется, что это способ написания программ, при котором несколько задач (потоков) могут выполняться одновременно в рамках одного процесса.

### 2. Процесс vs. Поток
Лектор объясняет ключевые различия между процессами и потоками:
- **Процесс**: Рассматривается как отдельная программа, запускаемая операционной системой (например, запуск Java-машины). Процессы имеют изолированную память. В качестве примера приводится браузер Chrome, который для каждой вкладки создает отдельный процесс.
- **Поток (Thread)**: Существует внутри процесса и разделяет с другими потоками общую память (общие переменные, классы в Java). Это "подпрограммы" внутри основной программы.

### 3. Зачем нужна многопоточность?
Обсуждается мотивация использования многопоточности:
- **Закон Мура**: Ранее этот закон трактовался как удвоение мощности процессоров каждые 18 месяцев за счет увеличения скорости. Однако из-за физических ограничений, современные процессоры наращивают мощность не за счет скорости, а за счет увеличения количества ядер, то есть способности выполнять несколько инструкций *одновременно*.
- **Ускорение программы**: Если программа может быть разделена на независимые задачи, их параллельное выполнение на многоядерном процессоре может значительно ускорить общую работу.

### 4. Ограничения параллелизма
Лектор приводит аналогию со сборкой компьютера командой из нескольких человек, чтобы проиллюстрировать ограничения:
- **Параллельная работа**: Если несколько человек одновременно собирают разные детали, работа ускоряется.
- **"Бутылочное горлышко"**: Если после сборки каждой детали ее нужно устанавливать в корпус системного блока, а это может делать только один человек в один момент времени, то возникает очередь. Эта часть работы не распараллеливается и становится "бутылочным горлышком", которое ограничивает общее ускорение. Даже если детали создаются очень быстро, общая скорость сборки упирается в последовательный этап.

Таким образом, не все части программы можно эффективно распараллелить, и это важно учитывать при проектировании многопоточных приложений.
