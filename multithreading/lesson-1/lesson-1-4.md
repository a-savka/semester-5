
# Лекция 1-4: Методы wait(), notify() и notifyAll()

## Основные темы лекции:

### 1. Что такое `wait()`, `notify()` и `notifyAll()`?
Это фундаментальные методы класса `java.lang.Object`, предназначенные для координации потоков.

- **`wait()`**: Приостанавливает выполнение **текущего** потока и **освобождает монитор** (блокировку), который этот поток удерживает. Поток переходит в состояние ожидания до тех пор, пока другой поток не вызовет `notify()` или `notifyAll()` на **том же самом объекте**.
- **`notify()`**: Пробуждает **один случайный** поток, который ожидает на мониторе этого объекта.
- **`notifyAll()`**: Пробуждает **все** потоки, которые ожидают на мониторе этого объекта.

### 2. Ключевые особенности `wait()`
- **Вызывается только в `synchronized` блоке/методе**: `wait()` работает с монитором объекта, поэтому поток должен сначала захватить этот монитор (войти в `synchronized` блок), прежде чем его освободить и уйти в ожидание.
- **Освобождает монитор**: Это главное отличие от `Thread.sleep()`. Освобождение блокировки позволяет другим потокам войти в `synchronized` блок и, например, изменить условие, которого ждет первый поток.
- **Перегруженные версии**:
    - `wait()`: Ожидает бесконечно до вызова `notify()`/`notifyAll()`.
    - `wait(long timeout)`: Ожидает указанное количество миллисекунд или до вызова `notify()`/`notifyAll()`.
    - `wait(long timeout, int nanos)`: Версия с наносекундами.
- **Бросает `InterruptedException`**: Как и `sleep()`, `wait()` может быть прерван вызовом `interrupt()`, что приведет к выбросу `InterruptedException`.

### 3. Паттерн "Производитель-Потребитель" (Producer-Consumer)
Это классический пример использования `wait()` и `notify()`. Один или несколько потоков ("производители") добавляют элементы в общую очередь, а другие потоки ("потребители") их оттуда забирают.

- Если очередь полна, производитель должен ждать (`wait()`), пока потребитель не заберет элемент.
- Если очередь пуста, потребитель должен ждать (`wait()`), пока производитель не добавит элемент.

#### Пример реализации:
```java
// Общий буфер (очередь)
class Buffer {
    private final Queue<Integer> queue = new LinkedList<>();
    private final int capacity;

    public Buffer(int capacity) {
        this.capacity = capacity;
    }

    // Метод для производителя
    public synchronized void put(int element) throws InterruptedException {
        // Если буфер полон, производитель ждет
        while (queue.size() == capacity) {
            System.out.println("Буфер полон, производитель ждет...");
            wait();
        }
        queue.add(element);
        System.out.println("Производитель добавил: " + element);
        // Уведомляем потребителей, что появился новый элемент
        notifyAll();
    }

    // Метод для потребителя
    public synchronized int take() throws InterruptedException {
        // Если буфер пуст, потребитель ждет
        while (queue.isEmpty()) {
            System.out.println("Буфер пуст, потребитель ждет...");
            wait();
        }
        int element = queue.poll();
        System.out.println("Потребитель забрал: " + element);
        // Уведомляем производителей, что появилось свободное место
        notifyAll();
        return element;
    }
}

// Пример использования в main (не показан в лекции, но подразумевается)
public class Main {
    public static void main(String[] args) {
        Buffer buffer = new Buffer(2);

        // Поток-производитель
        new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    buffer.put(i);
                    Thread.sleep(500); // Имитация работы
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();

        // Поток-потребитель
        new Thread(() -> {
            try {
                for (int i = 0; i < 5; i++) {
                    buffer.take();
                    Thread.sleep(1000); // Имитация работы
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }).start();
    }
}
```

### 4. Сравнение `wait()` и `sleep()`

| Характеристика      | `wait()`                                  | `Thread.sleep()`                          |
|---------------------|-------------------------------------------|-------------------------------------------|
| **Класс**           | `Object`                                  | `Thread`                                  |
| **Освобождение монитора** | **Да**, освобождает блокировку            | **Нет**, не освобождает блокировку        |
| **Контекст вызова** | Только внутри `synchronized` блока/метода | В любом месте                             |
| **Пробуждение**     | По вызову `notify()`/`notifyAll()` или таймауту | Только по истечении времени или `interrupt()` |
| **Назначение**      | Координация потоков, ожидание условия     | Простая пауза в выполнении потока         |

### 5. Когда использовать `wait()`?
- Для реализации сложных сценариев взаимодействия потоков, где один поток должен ждать выполнения условия другим потоком (например, "Производитель-Потребитель").
- Когда необходимо явное управление состоянием и координация.

**Важно**: В современном Java для многих задач, где раньше использовали `wait`/`notify`, существуют более удобные и безопасные классы в пакете `java.util.concurrent` (например, `BlockingQueue`, `CountDownLatch`, `Semaphore`).
