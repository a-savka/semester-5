
# Лекция 1-7: Метод yield() и его особенности

## Основные темы лекции:

### 1. Что такое `Thread.yield()`?
`Thread.yield()` — это статический `native` метод класса `Thread`, который является **подсказкой** для планировщика потоков. Вызывая `yield()`, текущий поток сообщает планировщику, что он готов временно уступить свое процессорное время другому потоку с таким же или более высоким приоритетом.

Ключевое слово здесь — **"подсказка"**. Планировщик потоков (как часть JVM и операционной системы) имеет полное право **проигнорировать** этот вызов. Нет никаких гарантий, что переключение контекста действительно произойдет.

### 2. Ключевые особенности `yield()`
- **Ненадежность и непредсказуемость**: Поведение `yield()` сильно зависит от реализации JVM и операционной системы. Полагаться на него для управления порядком выполнения потоков нельзя.
- **Не блокирует поток**: Поток, вызвавший `yield()`, не переходит в состояние блокировки. Он остается в состоянии `RUNNABLE` и может быть немедленно снова выбран планировщиком для выполнения.
- **Не освобождает мониторы**: Если `yield()` вызывается внутри `synchronized` блока, монитор (блокировка) **не освобождается**.
- **Не делает паузу**: В отличие от `sleep()`, `yield()` не гарантирует паузу. Если нет других потоков, готовых к выполнению, тот же самый поток может немедленно продолжить свою работу.
- **Не выбрасывает `InterruptedException`**: `yield()` не может быть прерван и не бросает это исключение.

### 3. Пример использования
В лекции приводится пример, который наглядно демонстрирует непредсказуемость `yield()`. Два потока вызывают `yield()` после первой итерации, но результат их выполнения меняется от запуска к запуску, показывая, что планировщик то следует подсказке, то игнорирует ее.

```java
public class YieldExample {
    public static void main(String[] args) {
        Runnable task = () -> {
            for (int i = 0; i < 2; i++) {
                System.out.println("Поток '" + Thread.currentThread().getName() + "' выполняет шаг " + (i + 1));
                if (i == 0) {
                    System.out.println("  -> Поток '" + Thread.currentThread().getName() + "' вызывает yield().");
                    // Предлагаем уступить процессор
                    Thread.yield();
                }
            }
            System.out.println("Поток '" + Thread.currentThread().getName() + "' завершен.");
        };

        Thread thread1 = new Thread(task, "Thread-1");
        Thread thread2 = new Thread(task, "Thread-2");

        System.out.println("Запускаем потоки...");
        thread1.start();
        thread2.start();
    }
}
```
При многократном запуске этого кода порядок вывода сообщений будет разным, что доказывает недетерминированность `yield()`.

### 4. Когда (теоретически) можно использовать `yield()`?
- **При тестировании**: Чтобы искусственно увеличить вероятность переключения между потоками и выявить потенциальные проблемы синхронизации.
- **Для низкоприоритетных задач**: Если поток выполняет фоновую, некритичную работу (например, логирование), он может периодически вызывать `yield()`, чтобы дать шанс более важным потокам.

На практике `yield()` используется **крайне редко** из-за своей непредсказуемости. Для надежного управления потоками следует использовать другие механизмы синхронизации.

### 5. Сравнение `yield()`, `sleep()`, `wait()` и `join()`

| Характеристика      | `yield()`                                 | `sleep()`                                 | `wait()`                                  | `join()`                                  |
|---------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|-------------------------------------------|
| **Назначение**      | **Предложить** уступить процессор         | **Гарантированная** пауза                 | Ожидание условия от другого потока        | Ожидание **завершения** другого потока    |
| **Гарантии**        | **Нет**                                   | Да (минимальная пауза)                    | Да (ждет сигнала)                         | Да (ждет завершения)                      |
| **Освобождение монитора** | Нет                                       | Нет                                       | **Да**                                    | Нет                                       |
| **Прерывание**      | Не прерывается (`InterruptedException`)   | Прерывается                               | Прерывается                               | Прерывается                               |
| **Контекст вызова** | В любом месте                             | В любом месте                             | Только в `synchronized` блоке/методе      | В любом месте                             |

## Итог
`yield()` — это низкоуровневый и ненадежный инструмент, который не следует использовать в большинстве реальных приложений. Он служит скорее для отладки и демонстрации работы планировщика потоков, чем для построения предсказуемой многопоточной логики.
