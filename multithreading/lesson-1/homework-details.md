# Все детали о домашнем задании и итоговом проекте (Вебинар 1)

Этот документ содержит исчерпывающую информацию, касающуюся домашнего задания после первого вебинара и требований к итоговому проекту, озвученных лектором.

## 1. Итоговый проект: Общая концепция и цели

### Основная задача

Разработать **веб-сервис для автоматизированного сбора данных** из различных интернет-источников. Ключевым требованием является **использование многопоточности** для выполнения сбора данных.

### Варианты заданий

Проект будет выполняться по вариантам. Лектор упомянул несколько возможных тем:

- **Курсы валют:** Сбор данных о курсах валют.
- **Карточки товаров:** Сбор информации о товарах с маркетплейсов.
- **Новости или отзывы:** Сбор новостей или отзывов с каких-либо сайтов.

> **Цитата лектора:** *"Какие данные должно собирать приложение? Это будет описано в задании, там оно будет по вариантам, там, по-моему, есть курсы валют, есть карточка товара, вот, я не помню, с новостями что-то, по-моему, было с отзывами, с каких-то маркетплейсов..."*

### Ключевые технологии и требования

- **Язык:** Проект должен быть написан **строго на Java**.
- **Фреймворк:** Рекомендуется использовать **Spring Boot**.
- **Многопоточность:** Это центральный элемент проекта. Вы должны будете продемонстрировать понимание и применение концепций, изученных в курсе, включая:
    - Пулы потоков и их оптимизация (будет рассмотрено позже).
    - Синхронизированные структуры данных (например, потокобезопасные коллекции).
    - Планирование задач и автоматизация процессов (через `ExecutorService`, будет рассмотрено позже).
    - Интеграция с базами данных в многопоточной среде.

> **Цитата лектора:** *"В рамках итогового задания, вы должны продемонстрировать там все возможности... всю информацию, которая была дана в рамках курса, да, если вы ее продемонстрируете, будет очень круто... Сюда может подойти и пул и потоков оптимизации, которым мы будем в дальнейшем рассматривать, вот для структуры данных... есть синхронизированные структуры, про них мы тоже будем рассказывать. Планирование задач и автоматизирование процессов... и интеграция с базами данных в многопоточной среде..."*

### Рекомендации по выполнению

- **Начинайте заранее:** Не откладывайте работу на последний момент. Настройка и отладка многопоточного приложения требует времени.
- **Работайте системно:** Постепенно наращивайте функциональность.

> **Цитата лектора:** *"...вам рекомендовано начинать делать работу, ну, начиная там с завтрашнего дня... просто главная системность, если вы в конце срока сядите, у вас в большинстве случаев может приложение не заработать, потому что очень много разных параметров, которые нужно выставлять..."*

## 2. Настройка рабочего окружения и каркаса проекта

Лектор дал подробные инструкции по созданию и настройке Spring Boot приложения, которое станет основой для итогового проекта.

### Шаг 1: Создание проекта через Spring Initializer

- **Сайт:** [start.spring.io](https://start.spring.io)
- **Параметры проекта:**
    - **Project:** `Maven Project`
    - **Language:** `Java`
    - **Spring Boot:** Версия `3.x.x` (в примере была 3.5.5, но подразумевается любая актуальная 3-я версия).
    - **Project Metadata:**
        - **Group:** `com.example` (лектор рекомендовал использовать свою фамилию для уникальности, например `com.mskaliev`).
        - **Artifact:** `bank-app` (или другое осмысленное имя).
    - **Packaging:** `Jar`
    - **Java:** `17` (важно, так как Spring Boot 3 требует Java 17+).

### Шаг 2: Добавление зависимостей

На сайте Spring Initializer нужно добавить следующие зависимости:

1.  **Spring Web:** Для создания веб-приложения, контроллеров, обработки HTTP-запросов.
2.  **Spring Data JPA:** Для упрощенной работы с базами данных через репозитории.
3.  **H2 Database:** Встраиваемая база данных, работающая в памяти. **Настоятельно рекомендуется** для проекта, чтобы упростить проверку (рецензенту не придется настраивать внешнюю БД вроде PostgreSQL).

### Шаг 3: Конфигурация `pom.xml`

После генерации проекта `pom.xml` будет содержать все указанные зависимости. Лектор также упомянул родительский `pom` (`spring-boot-starter-parent`), который управляет версиями зависимостей, обеспечивая их совместимость.

### Шаг 4: Конфигурация `application.properties`

Это ключевой файл для настройки поведения приложения. Он находится в `src/main/resources/`.

```properties
# Имя приложения (не обязательно, но полезно)
spring.application.name=bank-app

# Порт, на котором будет работать веб-сервер
server.port=8080

# ===============================================
# НАСТРОЙКИ ВСТРАИВАЕМОЙ БАЗЫ ДАННЫХ H2
# ===============================================

# Включаем веб-консоль для доступа к базе через браузер
spring.h2.console.enabled=true
# Указываем путь, по которому будет доступна консоль (http://localhost:8080/h2-console)
spring.h2.console.path=/h2-console

# ===============================================
# НАСТРОЙКИ ПОДКЛЮЧЕНИЯ К ДАННЫМ (DataSource)
# ===============================================

# URL для подключения к H2 в режиме "in-memory" (в памяти)
# bankdb - это имя экземпляра базы данных
spring.datasource.url=jdbc:h2:mem:bankdb

# Драйвер для работы с H2
spring.datasource.driverClassName=org.h2.Driver

# Имя пользователя и пароль для доступа к базе
spring.datasource.username=sa
spring.datasource.password=

# ===============================================
# НАСТРОЙКИ JPA (Hibernate)
# ===============================================

# Указываем Hibernate, чтобы он НЕ создавал/изменял таблицы автоматически.
# Мы будем управлять структурой БД сами с помощью schema.sql
spring.jpa.hibernate.ddl-auto=none

# Включаем отображение SQL-запросов, которые Hibernate выполняет, в консоли.
# Это очень удобно для отладки.
spring.jpa.show-sql=true
```

### Шаг 5: Инициализация базы данных

Чтобы при старте приложения база данных имела нужную структуру и начальные данные, нужно создать два файла в `src/main/resources/`:

1.  **`schema.sql`**: Содержит DDL-запросы (`CREATE TABLE ...`) для создания структуры таблиц.
2.  **`data.sql`**: Содержит DML-запросы (`INSERT INTO ...`) для наполнения таблиц начальными данными.

### Шаг 6: Создание `README.md`

Лектор особо подчеркнул важность создания файла `README.md` в корне проекта. В нем должно быть:

- Краткое описание логики приложения.
- Инструкции по запуску.
- Примеры запросов (какой метод дернуть, с какими параметрами).
- Примеры SQL-запросов для проверки данных в базе.

> **Цель:** Рецензент должен иметь возможность запустить и проверить проект с минимальными ручными настройками.

## 3. Домашнее задание после первого вебинара

Это задание **не для строгой проверки**, а для самостоятельной практики и подготовки к итоговому проекту.

1.  **Ознакомиться с итоговым проектом:** Прочитать описание и понять архитектуру будущего приложения.
2.  **Создать каркас приложения:** Выполнить все шаги по настройке Spring Boot проекта, описанные выше.
3.  **Поднять простейший сервис:** Убедиться, что приложение запускается без ошибок.
4.  **Реализовать простые потоки:** Внутри созданного Spring Boot приложения (например, в `main` методе или в специальном тестовом классе) воспроизвести примеры с вебинара:
    - Создать потоки через `new Thread()` и `Runnable`.
    - Логика потоков должна быть связана с темой вашего будущего проекта. Например, просто выводить в консоль: `"Поток [Имя потока] начал сбор курса валют..."`.
    - **Не нужно** на этом этапе подключаться к реальным внешним сервисам. Достаточно имитации.
5.  **Поэкспериментировать:**
    - Присвоить потокам осмысленные имена.
    - Вывести в консоль стек вызовов (`Thread.dumpStack()`).
    - Вывести список всех активных потоков.

> **Цитата лектора:** *"Попробуйте создать внутри Spring... простые реализации Thread и Runnable... например, если у вас там приложение по курсу валют, просто создайте вывод курса валют без подключения с каких-то сторонних ресурсов, просто руками... как было на вебинаре, но в контексте своего приложения, чтобы вы уже старались понять, как его применить в дальнейшем..."*

## 4. Дополнительные советы и заметки

- **Структура кода:** Приложение должно быть разделено на логические слои: `Controller` (обработка HTTP-запросов), `Service` (бизнес-логика), `Repository` (взаимодействие с базой данных).
- **Альтернатива базе данных:** Если возникнут непреодолимые сложности с подключением БД, лектор допустил использование **файла как внешнего хранилища**. Однако в этом случае вам придется самостоятельно реализовать логику парсинга данных из файла в Java-объекты (например, с помощью `ObjectMapper` для JSON) и обратно. Этот путь считается более сложным.
- **Парсинг данных:** При работе с внешними API вам нужно будет парсить полученные данные (чаще всего в формате JSON) в ваши Java-классы (`Entity`).
