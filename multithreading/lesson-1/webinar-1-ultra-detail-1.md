# Конспект вебинара 1: Основы многопоточности в Java

## 1. Организационные моменты и знакомство

- **Ведущий:** Василий Мскалев, разработчик в группе компаний "Натеха" (банковские решения).
- **Рекомендации для слушателей:**
    - Использовать Google Chrome для вебинаров.
    - Вести конспекты в текстовом формате.
- **Важность практики:** Теоретические знания лучше всего усваиваются при решении реальных "боевых" задач.
- **План вебинара:** Начать с простых примеров и постепенно перейти к приложению на Spring Boot.
- **Вопросы:** Задавать вопросы в общем чате, а не в личных сообщениях. Также можно использовать платформу "Нетологии".

## 2. Введение в многопоточное программирование

### Цели многопоточного программирования

- **Параллельная обработка запросов:** Основная цель — обрабатывать множество запросов одновременно, чтобы избежать блокировок.
    - **Пример:** Если бы банковский сервер был однопоточным, он бы обрабатывал запросы клиентов последовательно. При тысячах клиентов это привело бы к огромным задержкам. Многопоточность позволяет обрабатывать их параллельно.
- **Моделирование параллельных процессов:**
    - **Пример:** Ледокол в Арктике с множеством датчиков, отправляющих данные на сервер. Обработка этих данных в одном потоке была бы неэффективной.
- **Эффективное использование ресурсов:** Современные компьютеры имеют многоядерные процессоры. Однопоточные приложения не используют их потенциал полностью. Многопоточность позволяет задействовать несколько ядер для выполнения сложных и повторяющихся задач.

### Процесс vs. Поток

- **Процесс:**
    - Экземпляр выполняемой программы (любая запущенная программа на компьютере).
    - Имеет выделенную, изолированную память. Процессы не мешают друг другу.
- **Поток (Thread):**
    - Структурная единица внутри процесса.
    - Все потоки одного процесса разделяют общее адресное пространство.
    - **Важно:** В Java один поток (`java.lang.Thread`) соответствует одному потоку операционной системы. Это обеспечивает предсказуемое поведение на разных платформах (Windows, macOS, Linux).

## 3. Цели занятия

1.  Научиться различать потоки и процессы.
2.  Разобраться в устройстве `Thread` внутри JVM.
3.  Понять, как именовать и приоритизировать потоки.
4.  Научиться добавлять обработчик исключений в поток.
5.  Познакомиться с типами потоков (демоны и не-демоны).

## 4. Создание потоков в Java

Существует два основных способа создания потоков:
1.  Создание экземпляра класса `java.lang.Thread`.
2.  Реализация интерфейса `java.lang.Runnable`.

### Способ 1: Класс `Thread`

Это самый простой способ. Логика потока описывается с помощью лямбда-выражения, которое передается в конструктор `Thread`.

**Пример кода:**

```java
public class ThreadExample {
    public static void main(String[] args) {
        // Создаем поток с помощью лямбда-выражения
        Thread thread1 = new Thread(() -> {
            // Получаем информацию о текущем потоке
            long id = Thread.currentThread().getId();
            String name = Thread.currentThread().getName();
            int priority = Thread.currentThread().getPriority();
            boolean isDaemon = Thread.currentThread().isDaemon();

            System.out.printf("Поток %s: ID=%d, Приоритет=%d, Демон=%b%n", name, id, priority, isDaemon);
        });

        Thread thread2 = new Thread(() -> {
            System.out.println("Информация о втором потоке...");
            // ... аналогично
        });

        // Запускаем поток. JVM вызывает метод run() в новом потоке.
        thread1.start();
        thread2.start();

        // ВАЖНО: Никогда не вызывайте thread.run() напрямую!
        // Это выполнит код в текущем (главном) потоке, а не в новом.
    }
}
```

- **`getId()`**: Возвращает уникальный идентификатор потока.
- **`getName()`**: Возвращает имя потока (по умолчанию `Thread-0`, `Thread-1` и т.д.).
- **`getPriority()`**: Возвращает приоритет потока (шкала от 1 до 10, по умолчанию 5).
- **`isDaemon()`**: Проверяет, является ли поток демоном.

**Количество потоков в примере:** В приведенном выше `main` методе работают **три** потока:
1.  **Главный поток (main thread):** Запускается при старте программы.
2.  **`thread1`**: Создан нами.
3.  **`thread2`**: Создан нами.

### Способ 2: Интерфейс `Runnable`

Этот способ более гибкий, так как позволяет классу с логикой наследоваться от другого класса (в Java нет множественного наследования классов).

**Шаг 1: Создать класс, реализующий `Runnable`**

```java
public class MyTask implements Runnable {
    @Override
    public void run() {
        for (int i = 1; i <= 5; i++) {
            System.out.println("Поток " + Thread.currentThread().getName() + ", счетчик: " + i);
            try {
                // Имитация долгой работы
                Thread.sleep(500); // Поток "засыпает" на 500 мс
            } catch (InterruptedException e) {
                System.out.println("Поток был прерван во время сна.");
                // ХОРОШАЯ ПРАКТИКА: Восстановить флаг прерывания
                Thread.currentThread().interrupt();
                // Прервать выполнение
                break;
            }
        }
        System.out.println("Поток " + Thread.currentThread().getName() + " завершен.");
    }
}
```

- **`InterruptedException`**: Это проверяемое исключение. Оно выбрасывается, если другой поток прерывает текущий (`interrupt()`), пока тот находится в состоянии ожидания (`sleep()`, `wait()`, `join()`).
- **`Thread.currentThread().interrupt()`**: Когда `InterruptedException` перехватывается, флаг прерывания потока сбрасывается. Эта строка восстанавливает его, чтобы другой код мог проверить, был ли поток прерван.

**Шаг 2: Создать `Thread` и передать ему `Runnable`**

```java
public class RunnableExample {
    public static void main(String[] args) throws InterruptedException {
        Runnable myTask = new MyTask();
        Thread thread = new Thread(myTask);
        thread.start();

        // Метод join() заставляет главный поток ждать завершения дочернего потока
        thread.join(); 

        System.out.println("Главный поток завершен.");
    }
}
```

- **`thread.join()`**: Без этого метода главный поток мог бы завершиться раньше, чем `myTask`. `join()` гарантирует, что основной поток дождется окончания работы `thread`.

## 5. Управление потоками

### Именование потоков

Для удобства отладки и логирования потокам следует давать осмысленные имена.

**Пример кода:**

```java
public class NamingThreads {
    public static void main(String[] args) {
        // Способ 1: Через конструктор
        Runnable task = () -> System.out.println("Работает поток: " + Thread.currentThread().getName());
        Thread worker1 = new Thread(task, "Worker-1");

        // Способ 2: Через сеттер
        Thread worker2 = new Thread(task);
        worker2.setName("Worker-2");

        worker1.start();
        worker2.start();
    }
}
```

### Стек вызовов (Stack Trace)

Каждый поток имеет свой собственный, независимый стек вызовов методов.

**Пример демонстрации:**

```java
public class StackTraceExample {

    public static void main(String[] args) {
        // 1. Стек вызовов главного потока
        System.out.println("Главный поток работает. Стек:");
        Thread.dumpStack();

        // 2. Стек вызовов вложенного потока
        new Thread(() -> {
            System.out.println("Вложенный поток работает. Стек:");
            level1();
        }, "Custom-Thread").start();
    }

    public static void level1() {
        level2();
    }

    public static void level2() {
        // Этот метод выведет стек вызовов, который будет включать level2, level1 и run.
        Thread.dumpStack();
    }
}
```
- `Thread.dumpStack()` - это удобный статический метод для вывода стека вызовов текущего потока в `System.err`.

### Обработка неперехваченных исключений

Если в потоке возникает неперехваченное исключение (`RuntimeException`), стандартный `try-catch` в родительском потоке его не поймает.

**Проблема:**
```java
public class ExceptionProblem {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            throw new RuntimeException("Что-то пошло не так!");
        });

        try {
            thread.start();
        } catch (Exception e) {
            // Этот блок НИКОГДА не выполнится
            System.err.println("Исключение поймано: " + e.getMessage());
        }
    }
}
```

**Решение: `UncaughtExceptionHandler`**

Это специальный обработчик, который вызывается, когда поток завершается из-за неперехваченного исключения.

**Пример кода:**

```java
public class ExceptionHandlerExample {
    public static void main(String[] args) {
        // 1. Создаем обработчик
        Thread.UncaughtExceptionHandler handler = (th, ex) -> {
            System.err.printf("ОШИБКА в потоке %s: %s%n", th.getName(), ex.getMessage());
        };

        // 2. Создаем поток и выбрасываем исключение
        Thread thread1 = new Thread(() -> {
            System.out.println("Поток " + Thread.currentThread().getName() + " запускается...");
            throw new RuntimeException("User Not Found");
        }, "Database-Worker");

        // 3. Устанавливаем обработчик для конкретного потока
        thread1.setUncaughtExceptionHandler(handler);

        thread1.start();

        // Также можно установить обработчик по умолчанию для всех потоков
        // Thread.setDefaultUncaughtExceptionHandler(handler);
    }
}
```

## 6. Типы потоков: Демоны и не-демоны

- **Обычные потоки (User Threads):** JVM не завершит работу, пока хотя бы один обычный поток активен. Это потоки, выполняющие основную работу приложения.
- **Потоки-демоны (Daemon Threads):** Выполняют фоновые, вспомогательные задачи (например, сборка мусора, логирование). JVM **не ждет** завершения потоков-демонов. Как только все обычные потоки завершились, JVM завершает работу, принудительно останавливая всех демонов.

**Пример кода:**

```java
public class DaemonThreadExample {
    public static void main(String[] args) {
        // Поток 1: Обычный (User) поток, который падает с ошибкой
        Thread mainWorker = new Thread(() -> {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException ignored) {}
            throw new RuntimeException("Сбой в основной логике!");
        }, "Main-Worker");

        // Поток 2: Фоновый (Daemon) поток, который работает в цикле
        Thread backgroundLogger = new Thread(() -> {
            int count = 0;
            while (true) { // Бесконечный цикл
                System.out.println("Демон-поток работает... " + count++);
                try {
                    Thread.sleep(250);
                } catch (InterruptedException e) {
                    break;
                }
            }
        }, "Background-Logger");

        // Помечаем второй поток как демон
        backgroundLogger.setDaemon(true);

        mainWorker.start();
        backgroundLogger.start();

        // Результат: Как только mainWorker упадет, JVM завершится,
        // и backgroundLogger будет оборван, не дойдя до конца.
        // Если убрать backgroundLogger.setDaemon(true), то он продолжит работать вечно.
    }
}
```

## 7. Приоритеты потоков

- Приоритет — это **рекомендация** для планировщика потоков ОС, а не строгая команда.
- Шкала: от `Thread.MIN_PRIORITY` (1) до `Thread.MAX_PRIORITY` (10). Нормальный — `Thread.NORM_PRIORITY` (5).
- Планировщик *старается* давать больше процессорного времени потокам с более высоким приоритетом, но это **не гарантировано**.
- **Вывод:** В большинстве обычных приложений изменение приоритетов не дает предсказуемого эффекта и редко используется. Это важно в системах реального времени (Real-Time Java).

## 8. Настройка проекта для домашнего задания (Spring Boot)

Лектор продемонстрировал создание и настройку Spring Boot приложения для итогового проекта.

1.  **Создание проекта:** Использовать **Spring Initializer** (`start.spring.io`).
    - **Project:** Maven
    - **Language:** Java
    - **Spring Boot:** 3.x.x
    - **Java:** 17
    - **Dependencies:** `Spring Web`, `Spring Data JPA`, `H2 Database`.
2.  **`pom.xml`:** Файл содержит все зависимости проекта.
3.  **`application.properties`:** Файл для конфигурации.
    ```properties
    # Имя приложения
    spring.application.name=bank-app

    # Порт сервера
    server.port=8080

    # --- H2 Database ---
    # Включаем веб-консоль H2
    spring.h2.console.enabled=true
    # Путь к консоли (http://localhost:8080/h2-console)
    spring.h2.console.path=/h2-console

    # --- DataSource ---
    # URL для подключения к базе данных в памяти
    spring.datasource.url=jdbc:h2:mem:bankdb
    spring.datasource.driverClassName=org.h2.Driver
    spring.datasource.username=sa
    spring.datasource.password=

    # --- JPA / Hibernate ---
    # Отключаем автоматическое создание таблиц Hibernate, будем использовать schema.sql
    spring.jpa.hibernate.ddl-auto=none
    # Показывать SQL-запросы в консоли
    spring.jpa.show-sql=true
    ```
4.  **Инициализация базы данных:**
    - Создать файл `src/main/resources/schema.sql` для структуры таблиц (`CREATE TABLE ...`).
    - Создать файл `src/main/resources/data.sql` для начальных данных (`INSERT INTO ...`).
5.  **`README.md`:** Рекомендуется создать файл с описанием проекта и инструкциями по запуску.

## 9. Домашнее задание

### Цель на конец курса (Итоговый проект)

- Разработать веб-сервис для автоматизированного сбора данных из интернет-источников (например, курсы валют, карточки товаров, отзывы) с использованием многопоточности.

### Задание после 1-го вебинара

Это задание для самостоятельной практики, чтобы закрепить материал.

1.  **Изучить** описание итогового проекта.
2.  **Создать каркас** Spring Boot приложения с помощью Spring Initializer.
3.  **Реализовать** внутри этого приложения простые примеры с `Thread` и `Runnable` (как на вебинаре), но в контексте вашей будущей задачи (например, просто выводить в консоль "Получаю курс доллара...").
4.  **Поэкспериментировать** с именованием потоков, выводом стека вызовов и обработкой исключений.

## Ключевые выводы (Key Takeaways)

- Многопоточность необходима для создания отзывчивых и производительных приложений, которые эффективно используют ресурсы современных процессоров.
- В Java есть два основных способа создания потоков: наследование от `Thread` и реализация `Runnable`. Второй способ предпочтительнее.
- Управление потоками включает их запуск (`start()`), ожидание (`join()`), именование и обработку исключений (`UncaughtExceptionHandler`).
- Потоки-демоны служат для фоновых задач и не мешают завершению работы приложения.
- Приоритеты потоков являются лишь подсказкой для планировщика и не гарантируют порядок выполнения.
- Для сложных приложений стоит использовать фреймворки вроде Spring Boot, который упрощает настройку и управление.
