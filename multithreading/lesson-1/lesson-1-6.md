
# Лекция 1-6: Прерывание потоков и метод interrupt()

## Основные темы лекции:

### 1. Логика работы метода `interrupt()`
Метод `interrupt()` не останавливает поток принудительно. Вместо этого он работает как механизм вежливой просьбы о завершении. Его основная задача — установить внутренний флаг прерывания (`interrupted status`) для указанного потока в состояние `true`.

Поток, в свою очередь, должен периодически проверять этот флаг и самостоятельно решать, как на него реагировать: завершить свою работу, прекратить текущую операцию или проигнорировать запрос.

### 2. Как проверить флаг прерывания?
Существует два способа проверить статус прерывания:
- **`boolean isInterrupted()`**: Это метод экземпляра (`thread.isInterrupted()`). Он просто возвращает значение флага (`true` или `false`), **не изменяя его**.
- **`static boolean interrupted()`**: Это статический метод (`Thread.interrupted()`). Он также возвращает значение флага, но с важным побочным эффектом: **он сбрасывает флаг в `false`** после проверки. Этот метод проверяет флаг *текущего* потока.

### 3. Исключение `InterruptedException`
Это ключевой аспект механизма прерываний.

- **Когда возникает?** Исключение выбрасывается, если метод `interrupt()` вызывается для потока, который в данный момент находится в состоянии ожидания или "сна" (то есть выполняет один из методов: `sleep()`, `wait()` или `join()`).
- **Что происходит с флагом?** Когда `InterruptedException` выбрасывается, **флаг прерывания автоматически сбрасывается (становится `false`)**. Это сделано для того, чтобы обработчик исключения имел полный контроль над дальнейшими действиями.

### 4. Как правильно обрабатывать `InterruptedException`
Поскольку флаг прерывания сбрасывается, просто перехватить исключение недостаточно. Если этого не сделать, вышестоящий код может не узнать, что поток был прерван. Правильная обработка критически важна.

**Правильный алгоритм обработки:**
1.  Поместить вызов блокирующего метода (`sleep`, `wait`, `join`) в блок `try-catch`.
2.  В блоке `catch (InterruptedException e)`:
    a. (Опционально) Выполнить очистку ресурсов (закрыть файлы, соединения и т.д.).
    b. **(Обязательно!) Восстановить флаг прерывания**, вызвав `Thread.currentThread().interrupt()`. Это сохраняет информацию о том, что поток был прерван, для кода, который будет выполняться выше по стеку вызовов.
    c. Завершить выполнение метода (например, через `return` или `break`), так как продолжение работы в большинстве случаев некорректно.

#### Пример кода:
```java
class Worker implements Runnable {
    @Override
    public void run() {
        int step = 1;
        // Цикл продолжается, пока флаг прерывания не установлен
        while (!Thread.currentThread().isInterrupted()) {
            System.out.println("Worker выполняет шаг: " + step++);
            try {
                // Имитация долгой работы
                Thread.sleep(500);
            } catch (InterruptedException e) {
                // 1. Логируем или выводим сообщение об ошибке
                System.out.println("Поток был прерван во время сна.");

                // 2. (ВАЖНО!) Восстанавливаем флаг прерывания
                Thread.currentThread().interrupt();

                // 3. Прекращаем работу
                break; // или return;
            }
        }
        System.out.println("Worker завершил работу. Статус прерывания: " + Thread.currentThread().isInterrupted());
    }
}

public class InterruptExample {
    public static void main(String[] args) throws InterruptedException {
        Thread workerThread = new Thread(new Worker());
        workerThread.start();

        // Даем worker'у поработать 2 секунды
        Thread.sleep(2000);

        // Отправляем запрос на прерывание
        System.out.println("Главный поток прерывает Worker'а...");
        workerThread.interrupt();
    }
}
```
Если в блоке `catch` закомментировать строку `Thread.currentThread().interrupt()`, цикл `while` после исключения продолжится бесконечно (если убрать `break`), так как `isInterrupted()` будет всегда возвращать `false`.

## Выводы
- `interrupt()` — это кооперативный механизм, а не директивная команда.
- `InterruptedException` — это сигнал о том, что поток пытались прервать, пока он был неактивен.
- **Ключевое правило**: При перехвате `InterruptedException` почти всегда необходимо восстанавливать флаг прерывания с помощью `Thread.currentThread().interrupt()`, чтобы не "проглотить" сигнал о прерывании.
