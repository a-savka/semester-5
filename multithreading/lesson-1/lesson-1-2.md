
# Лекция 1-2: Создание и управление потоками в Java

## Основные темы лекции:

### 1. Способы создания потоков
В Java потоки представлены объектами. Существует два основных способа определить логику для нового потока:

- **Наследование от класса `Thread`**: Создается класс, который наследуется от `java.lang.Thread` и переопределяет его метод `run()`. Вся логика, которая должна выполняться в новом потоке, помещается в этот метод.

- **Реализация интерфейса `Runnable`**: Создается класс, который реализует интерфейс `java.lang.Runnable` и его единственный метод `run()`. Этот подход более гибкий, так как позволяет избежать множественного наследования. Объект этого класса, содержащий логику, передается в конструктор класса `Thread`.

### 2. Класс `Thread` и его основные методы
Класс `Thread` является центральным для работы с потоками. Основные моменты:

- **Создание и запуск**: Поток создается как экземпляр класса `Thread` и запускается вызовом метода `start()`. **Важно**: вызов `start()` запускает новый поток и выполняет метод `run()` асинхронно. Если же вызвать напрямую метод `run()`, новый поток не создастся, и код выполнится в текущем потоке.

- **Прерывание потока**: Метод `interrupt()` *не убивает* поток, а лишь посылает ему запрос на прерывание. Поток должен сам проверить этот флаг (например, через `Thread.currentThread().isInterrupted()`) и корректно завершить свою работу.

- **Другие методы**:
    - `getId()`: Возвращает уникальный идентификатор потока.
    - `setName(String name)` / `getName()`: Установка и получение имени потока для удобства отладки.
    - `setPriority(int priority)` / `getPriority()`: Попытка повлиять на планировщик потоков. Гарантий нет.
    - `sleep(long millis)`: Статический метод, который приостанавливает *текущий* поток на указанное количество миллисекунд. Может выбросить `InterruptedException`, если поток пытаются прервать во время "сна".

### 3. Примеры кода

#### Пример 1: Наследование от `Thread`
```java
class MyThread extends Thread {
    @Override
    public void run() {
        // Бесконечный цикл, который проверяет, не был ли установлен флаг прерывания
        while (!isInterrupted()) {
            // Какая-то полезная работа
        }
        System.out.println("Поток завершен.");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start(); // Запускаем новый поток

        // Основной поток что-то делает...

        myThread.interrupt(); // Просим другой поток завершиться
    }
}
```

#### Пример 2: Реализация `Runnable` с использованием лямбда-выражения
Этот способ является более современным и предпочтительным.

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        // Описываем логику потока через лямбда-выражение
        Runnable logic = () -> {
            for (int i = 0; i < 5; i++) {
                System.out.println("Привет из дочернего потока");
                try {
                    // Приостанавливаем поток на 500 мс
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    // Если поток прервали во время сна, завершаем его
                    System.out.println("Поток был прерван во время сна");
                    return; // Завершаем выполнение метода run()
                }
            }
        };

        // Создаем поток, передавая ему нашу логику
        Thread thread = new Thread(logic);
        thread.start(); // Запускаем

        // Основной поток тоже что-то делает
        for (int i = 0; i < 5; i++) {
            System.out.println("Привет из основного потока (main)");
            Thread.sleep(500);
        }
    }
}
```

### 4. Потоки-демоны (Daemon Threads)
- Поток можно пометить как "демон" с помощью `setDaemon(true)`.
- Программа (JVM) завершает свою работу, когда все *не-демонские* потоки завершились. Потоки-демоны принудительно останавливаются и не мешают завершению программы.
- Они полезны для фоновых задач, таких как периодическое сохранение данных или мониторинг.

### 5. Группы потоков (`ThreadGroup`)
- Потоки можно объединять в группы с помощью класса `ThreadGroup`.
- Это позволяет управлять несколькими потоками одновременно, например, прервать всю группу одним вызовом `interrupt()` на объекте группы.

## Итог
Лекция дает базовое понимание того, как создавать и управлять потоками в Java, подчеркивая разницу между наследованием от `Thread` и реализацией `Runnable`, а также объясняя ключевые методы для управления жизненным циклом потока.
