# Конспект вебинара 1: Основы многопоточности в Java

## 1. Введение в многопоточное программирование

### Цели многопоточности
- **Повышение производительности:** Использование нескольких ядер процессора для параллельного выполнения задач.
- **Отзывчивость приложений:** Особенно актуально для серверных приложений, которые должны одновременно обрабатывать запросы от множества клиентов, не блокируя друг друга.
- **Моделирование параллельных процессов:** Например, сбор данных с множества датчиков одновременно.

### Процесс vs. Поток
- **Процесс:** Экземпляр выполняемой программы с выделенной, изолированной памятью. (Пример: запущенный браузер, текстовый редактор).
- **Поток (Thread):** Структурная единица внутри процесса. Потоки одного процесса разделяют общее адресное пространство, что позволяет им эффективно взаимодействовать. В Java один поток приложения соответствует одному потоку операционной системы.

## 2. Создание потоков в Java

Существует два основных способа создания потоков.

### Способ 1: Наследование от класса `Thread`

Самый прямой способ. Логика потока определяется в переопределенном методе `run()`.

```java
// Создание потока через анонимный класс или лямбда-выражение
Thread thread = new Thread(() -> {
    // Получение информации о текущем потоке
    Thread current = Thread.currentThread();
    System.out.println("ID потока: " + current.getId());
    System.out.println("Имя потока: " + current.getName());
    System.out.println("Приоритет: " + current.getPriority());
    System.out.println("Это поток-демон? " + current.isDaemon());
});

// Для запуска потока необходимо вызвать метод start()
// Прямой вызов run() выполнит код в текущем (главном) потоке
thread.start();
```

### Способ 2: Реализация интерфейса `Runnable`

Это более гибкий и предпочтительный способ, так как он позволяет классу с логикой наследоваться от другого класса (в Java нет множественного наследования классов).

**1. Создаем класс с задачей:**
```java
class MyTask implements Runnable {
    @Override
    public void run() {
        try {
            for (int i = 0; i < 5; i++) {
                System.out.println("Поток " + Thread.currentThread().getName() + " выполняет шаг " + i);
                // Имитация долгой работы
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println("Поток был прерван во время сна.");
            // Хорошая практика - восстановить флаг прерывания,
            // чтобы другой код мог на него отреагировать.
            Thread.currentThread().interrupt();
        }
        System.out.println("Поток " + Thread.currentThread().getName() + " завершил работу.");
    }
}
```

**2. Создаем экземпляр `Thread`, передавая ему нашу задачу:**
```java
Runnable myTask = new MyTask();
Thread thread = new Thread(myTask);
thread.start();
```

## 3. Управление потоками

### Метод `join()` - Ожидание завершения потока

Главный поток может завершиться раньше, чем дочерние потоки. Чтобы дождаться их выполнения, используется метод `join()`.

```java
Thread childThread = new Thread(new MyTask());
childThread.start();

System.out.println("Главный поток ожидает завершения дочернего потока...");
try {
    // Главный поток блокируется и ждет, пока childThread не завершит свое выполнение
    childThread.join();
} catch (InterruptedException e) {
    e.printStackTrace();
}
System.out.println("Дочерний поток завершился. Главный поток продолжает работу.");
```

### Именование потоков

Осмысленное именование потоков помогает при отладке и логировании.

```java
Runnable task = () -> { /* какая-то логика */ };

// Способ 1: Через конструктор
Thread worker1 = new Thread(task, "Поток-обработчик-данных");

// Способ 2: Через сеттер
Thread worker2 = new Thread(task);
worker2.setName("Поток-для-логирования");

worker1.start();
worker2.start();
```

### Приоритеты потоков

Приоритет — это **рекомендация** планировщику потоков ОС, а не строгая команда. Он может влиять на то, какому потоку будет отдаваться предпочтение.
- Шкала от 1 (`Thread.MIN_PRIORITY`) до 10 (`Thread.MAX_PRIORITY`).
- По умолчанию — 5 (`Thread.NORM_PRIORITY`).

```java
Thread highPriorityThread = new Thread(() -> { /* ... */ });
Thread lowPriorityThread = new Thread(() -> { /* ... */ });

highPriorityThread.setPriority(Thread.MAX_PRIORITY); // Приоритет 10
lowPriorityThread.setPriority(Thread.MIN_PRIORITY);  // Приоритет 1

highPriorityThread.start();
lowPriorityThread.start();
```
**Важно:** Поведение планировщика зависит от ОС, и нет гарантии, что поток с более высоким приоритетом всегда будет выполняться первым.

## 4. Обработка исключений в потоках

Исключения, выброшенные в одном потоке, не могут быть перехвачены `try-catch` блоком в другом потоке. Для этого существует специальный механизм.

```java
// 1. Создаем обработчик
Thread.UncaughtExceptionHandler handler = (thread, exception) -> {
    System.err.println(
        "Перехвачена ошибка в потоке '" + thread.getName() + "': " + exception.getMessage()
    );
};

// 2. Создаем поток, который выбросит исключение
Thread errorThread = new Thread(() -> {
    throw new RuntimeException("Что-то пошло не так!");
});

// 3. Устанавливаем обработчик для конкретного потока
errorThread.setUncaughtExceptionHandler(handler);
errorThread.start();

// Можно также установить обработчик по умолчанию для всех потоков в приложении
// Thread.setDefaultUncaughtExceptionHandler(handler);
```

## 5. Потоки-демоны

- **Обычные потоки (не-демоны):** Приложение не завершит работу, пока хотя бы один такой поток активен.
- **Потоки-демоны (daemon threads):** Фоновые потоки, которые не мешают завершению приложения. Если все обычные потоки завершились, JVM принудительно останавливает всех демонов и завершает работу.

Примеры потоков-демонов: сборка мусора (Garbage Collector), фоновое логирование, мониторинг.

```java
Thread daemonThread = new Thread(() -> {
    while (true) {
        System.out.println("Демон работает в фоне...");
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            break;
        }
    }
});

// Помечаем поток как демон. Это нужно сделать до его запуска.
daemonThread.setDaemon(true);
daemonThread.start();

System.out.println("Главный поток поработал 2 секунды и завершается.");
Thread.sleep(2000);
// После завершения главного потока приложение сразу закроется,
// и поток-демон будет остановлен.
```
