# Детальный конспект вебинара 1: Основы многопоточности в Java

## 1. Введение и организационные моменты

- **Лектор:** Василий Мскалев, разработчик в группе компаний "Натеха" (банковские решения).
- **Контекст:** Лектор делится опытом использования многопоточности для создания отказоустойчивых банковских приложений, обрабатывающих большое количество клиентских подключений.
- **Рекомендации для слушателей:** Использовать браузер Google Chrome, подготовить блокнот для записей, быть знакомым с основами Java. Знание Spring Boot приветствуется, но не является обязательным.

## 2. Что такое многопоточное программирование и зачем оно нужно?

Многопоточное программирование — это подход, при котором выполнение программы разделяется на несколько потоков, исполняемых параллельно.

### Ключевые цели:

1.  **Утилизация ресурсов современных процессоров:** Современные компьютеры имеют много ядер, и однопоточные приложения не используют их потенциал полностью.
2.  **Повышение отзывчивости и производительности:**
    *   **Пример с сервером:** Если сервер однопоточный, он обрабатывает запросы от клиентов строго последовательно. Получив один запрос, он блокируется до его полного выполнения, и все остальные клиенты ждут в очереди. Это неприемлемо для высоконагруженных систем (например, банковских).
    *   Многопоточный сервер может обрабатывать множество запросов одновременно, выделяя на каждый запрос отдельный поток.
3.  **Моделирование параллельных реальных процессов:**
    *   **Пример с ледоколом:** Ледокол в Арктике оснащен множеством датчиков, которые постоянно отправляют данные на центральный сервер. Обрабатывать эти данные в одном потоке было бы неэффективно.

## 3. Процесс vs. Поток: Фундаментальные различия

- **Процесс:**
    - Это экземпляр запущенной программы (например, браузер, IDE).
    - Каждому процессу операционная система выделяет **изолированное адресное пространство (память)**.
    - Процессы не мешают друг другу работать.

- **Поток (Thread):**
    - Это структурная единица **внутри процесса**.
    - Все потоки, принадлежащие одному процессу, **разделяют общее адресное пространство**. Это позволяет им легко обмениваться данными, но также создает риски (состояния гонки, взаимные блокировки).
    - **Важный тезис в Java:** Java придерживается модели **1:1**, где один поток Java (`java.lang.Thread`) напрямую соответствует одному потоку операционной системы. Это обеспечивает кросс-платформенную предсказуемость поведения потоков.

## 4. Способы создания потоков в Java

### Способ 1: Наследование от класса `java.lang.Thread`

Это самый простой способ, но менее гибкий из-за отсутствия множественного наследования в Java.

```java
// Создание потока с помощью лямбда-выражения (доступно с Java 8)
// Лямбда () -> { ... } является реализацией функционального интерфейса Runnable
Thread thread = new Thread(() -> {
    // Thread.currentThread() - статический метод для получения текущего исполняемого потока
    Thread current = Thread.currentThread();
    System.out.println("ID потока: " + current.getId());
    System.out.println("Имя потока: " + current.getName()); // По умолчанию: Thread-0, Thread-1 и т.д.
    System.out.println("Приоритет: " + current.getPriority()); // По умолчанию: 5
    System.out.println("Это поток-демон? " + current.isDaemon()); // По умолчанию: false
});

// Ключевой момент: для запуска потока вызывается метод start()
// Он регистрирует поток в планировщике JVM и асинхронно вызывает метод run().
thread.start();

// Если вызвать thread.run() напрямую, код выполнится синхронно в текущем потоке,
// и новый поток создан не будет.
```

### Способ 2: Реализация интерфейса `java.lang.Runnable`

Это **предпочтительный** способ, так как он отделяет задачу (`Runnable`) от исполнителя (`Thread`) и оставляет возможность наследования от другого класса.

**1. Создание класса задачи:**
```java
class MyTask implements Runnable {
    @Override
    public void run() {
        try {
            for (int i = 1; i <= 5; i++) {
                System.out.println("Поток " + Thread.currentThread().getName() + " выполняет шаг " + i);
                // Thread.sleep() приостанавливает поток на указанное время.
                // Этот метод может выбросить InterruptedException.
                Thread.sleep(500);
            }
        } catch (InterruptedException e) {
            System.out.println("Поток был прерван извне.");
            // ВАЖНО: Когда выбрасывается InterruptedException, флаг прерывания потока сбрасывается.
            // Хорошей практикой является его восстановление, чтобы вышестоящий код
            // мог корректно отреагировать на факт прерывания.
            Thread.currentThread().interrupt();
            // Прерываем цикл после обработки исключения
            return;
        }
        System.out.println("Поток " + Thread.currentThread().getName() + " штатно завершил работу.");
    }
}
```

**2. Запуск задачи в потоке:**
```java
Runnable myTask = new MyTask();
Thread thread = new Thread(myTask);
thread.start();
```

## 5. Жизненный цикл и управление потоками

### `thread.join()` — Ожидание завершения

Проблема: главный поток (`main`) может завершить свою работу раньше, чем порожденные им дочерние потоки. Если дочерние потоки не являются демонами, приложение продолжит работать, но если они демоны, они будут прерваны. Метод `join()` решает проблему ожидания.

```java
Thread childThread = new Thread(new MyTask());
childThread.start();

try {
    // Текущий поток (main) блокируется и ждет, пока childThread не завершит свое выполнение.
    childThread.join();
} catch (InterruptedException e) {
    // join() также может быть прерван
    e.printStackTrace();
}
System.out.println("Дочерний поток точно завершился. Главный поток продолжает.");
```

### Именование и приоритеты

- **Именование:** Критически важно для отладки. Позволяет по логам понять, какой именно поток выполняет какую работу.
  ```java
  Thread worker = new Thread(new MyTask(), "File-Downloader");
  worker.setName("Log-Processor"); // Можно и так
  ```
- **Приоритеты:**
    - Это лишь **рекомендация** планировщику потоков ОС. Нет гарантии, что поток с высоким приоритетом всегда будет выполняться раньше.
    - Шкала: `1` (мин) - `5` (норма) - `10` (макс).
    - Лектор упоминает **Real-time Java**, где приоритеты соблюдаются строго, что необходимо для систем, где время выполнения критично (например, в космонавтике).

### Обработка неперехваченных исключений

Блок `try-catch` в одном потоке не может поймать исключение, возникшее в другом, так как у каждого потока свой стек вызовов.

```java
// 1. Создаем обработчик. Это функциональный интерфейс.
Thread.UncaughtExceptionHandler handler = (thread, exception) -> {
    System.err.println(
        "ОШИБКА: В потоке '" + thread.getName() + "' произошло исключение: " + exception.getMessage()
    );
    // Здесь можно логировать ошибку, пытаться перезапустить задачу и т.д.
};

Thread errorThread = new Thread(() -> {
    throw new RuntimeException("Пользователь не найден!");
});

// 2. Применяем обработчик к конкретному потоку
errorThread.setUncaughtExceptionHandler(handler);
errorThread.start();

// 3. Или устанавливаем обработчик по умолчанию для всех потоков в приложении
// Thread.setDefaultUncaughtExceptionHandler(handler);
```

### Потоки-демоны

- **Определение:** Фоновые потоки, которые не препятствуют завершению работы JVM.
- **Ключевое свойство:** JVM завершает работу, когда **все обычные (не-демоны) потоки** завершили свое выполнение. При этом все потоки-демоны **принудительно и немедленно обрываются**.
- **Аналогия лектора:**
    - **Обычный поток:** Основная логика (например, `saveUser()`). Если она падает, приложение не должно работать.
    - **Поток-демон:** Вспомогательная, фоновая логика (например, логирование количества записей в БД, сборка мусора). Если основная логика упала, нет смысла продолжать выполнять фоновую.

```java
Thread daemon = new Thread(() -> {
    while (true) { /* какая-то фоновая работа */ }
});

// Поток нужно пометить как демон ДО его запуска
daemon.setDaemon(true);
daemon.start();

// Как только главный поток завершится, демон будет оборван.
```

## 6. Краткое введение в Spring Boot для проекта

Лектор показал, как создать каркас проекта для домашнего задания.

1.  **Spring Initializr (`start.spring.io`):** Инструмент для генерации структуры проекта.
2.  **`pom.xml`:** Файл конфигурации Maven, где объявляются зависимости.
    - `spring-boot-starter-web`: для создания веб-приложений, REST-контроллеров.
    - `spring-boot-starter-data-jpa`: для работы с базами данных через JPA (Hibernate).
    - `h2database`: встраиваемая база данных, удобная для разработки и тестирования.
3.  **`application.properties`:** Файл для настройки приложения (порт сервера, подключение к БД и т.д.).
4.  **`README.md`:** Настоятельная рекомендация создать этот файл в проекте, чтобы описать его логику и как его запускать для проверяющего.
