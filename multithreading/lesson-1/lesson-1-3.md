
# Лекция 1-3: Метод Thread.sleep() и его особенности

## Основные темы лекции:

### 1. Что такое `Thread.sleep()`?
`Thread.sleep()` — это статический метод класса `java.lang.Thread`, который используется для приостановки выполнения **текущего** потока на заданный промежуток времени. Этот метод часто применяется для имитации задержек, создания таймеров или для того, чтобы дать другим потокам возможность поработать.

Важной деталью является то, что `sleep()` — это `native` метод. Это означает, что его реализация написана не на Java, а на низкоуровневом языке (например, C++) и является частью JVM.

### 2. Как объявлять `Thread.sleep()`
Метод имеет две перегруженные версии:
- `sleep(long millis)`: Приостанавливает поток на указанное количество миллисекунд.
- `sleep(long millis, int nanos)`: Приостанавливает поток на указанное количество миллисекунд и наносекунд. Точность наносекунд зависит от реализации JVM и операционной системы и часто может игнорироваться.

Поскольку `Thread.sleep()` может выбросить проверяемое исключение `InterruptedException`, его вызов **обязательно** должен быть обернут в блок `try-catch` или метод должен пробрасывать это исключение дальше.

### 3. Ключевые особенности `Thread.sleep()`
- **Приостанавливает только текущий поток**: Другие потоки продолжают свое выполнение.
- **Не освобождает мониторы (блокировки)**: Если поток вызвал `sleep()` внутри `synchronized` блока, он не освободит захваченный монитор. Другие потоки не смогут войти в этот блок, пока "спящий" поток не проснется и не выйдет из него.
- **Может быть прерван**: Другой поток может прервать "спящий" поток, вызвав у его объекта метод `interrupt()`. В этом случае `sleep()` немедленно завершится и выбросит `InterruptedException`.
- **Точность не гарантирована**: Реальная задержка может быть немного больше указанной из-за особенностей планировщика потоков операционной системы.
- **Не для точного контроля времени**: Для критически важных по времени операций лучше использовать более продвинутые инструменты из пакета `java.util.concurrent`, такие как `CyclicBarrier` или `CountDownLatch`.

### 4. Пример использования
В лекции приводится пример с двумя потоками, которые выполняют свою работу с разной задержкой, чтобы продемонстрировать, как планировщик потоков может переключаться между ними.

```java
// Класс, реализующий логику для потока
class MyRunnable implements Runnable {
    private final String name;
    private final long delay;

    public MyRunnable(String name, long delay) {
        this.name = name;
        this.delay = delay;
    }

    @Override
    public void run() {
        System.out.println("Поток '" + name + "' запущен.");
        try {
            for (int i = 1; i <= 3; i++) {
                System.out.println("  " + name + ": шаг " + i);
                // Приостанавливаем текущий поток
                Thread.sleep(delay);
            }
        } catch (InterruptedException e) {
            // Обрабатываем прерывание потока
            Thread.currentThread().interrupt(); // Восстанавливаем флаг прерывания
            System.out.println("Поток '" + name + "' был прерван.");
        }
        System.out.println("Поток '" + name + "' завершил работу.");
    }
}

public class SleepExample {
    public static void main(String[] args) {
        System.out.println("Главный поток запущен.");

        // Создаем два потока с разной задержкой
        Thread thread1 = new Thread(new MyRunnable("Поток 1", 500));
        Thread thread2 = new Thread(new MyRunnable("Поток 2", 700));

        thread1.start();
        thread2.start();

        try {
            // Дадим дочерним потокам поработать
            System.out.println("Главный поток спит на 1 секунду.");
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        System.out.println("Главный поток завершен.");
    }
}
```

### 5. Когда использовать `Thread.sleep()`?
- Для имитации долгой операции при тестировании.
- Чтобы дать другим потокам шанс выполниться (хотя это не надежный способ синхронизации).
- Для создания простых задержек в некритичных участках кода (например, в анимациях или играх).
- Когда нужно временно снизить нагрузку на процессор от слишком быстрого цикла.
